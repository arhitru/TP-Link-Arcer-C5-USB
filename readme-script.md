Вступление
OpenWRT можно настроить с помощью extroot для использования внешнего устройства хранения (USB, SATA, SD-карты и т.д.) для расширения вашей корневой файловой системы и свободной установки всех необходимых вам пакетов.

На большинстве поддерживаемых устройств OpenWRT разделяет внутреннюю память на разделы rootfs и rootfs_data или ubifs, которые объединяются в единую файловую систему overlay, доступную для записи.

OpenWRT помещается даже в небольшие объемы внутренней памяти (всего 4 Мб), но при этом позволяет записывать настройки и устанавливать некоторые пакеты в раздел, доступный для записи, без изменения всех используемых программ Linux. Extroot работает путем установки другого оверлейного раздела на внешнем устройстве хранения, и во время загрузки этот новый оверлейный раздел будет смонтирован поверх оверлейного раздела внутреннего хранилища. Этот подход также позволяет легко выполнить резервное копирование в случае удаления внешнего запоминающего устройства, поскольку ваше устройство по-прежнему будет иметь свой собственный раздел overlay и, таким образом, будет загружать всю конфигурацию оттуда. Это означает, что он будет вести себя точно так же, как и до настройки extroot.

Обратите внимание, что OpenWRT, как известно, игнорирует конфигурацию fstab на устройствах без оверлейного раздела в /proc/mtd. Вы можете обойти эту проблему, используя / для точки монтирования на ПЗУ вообще без оверлейного раздела. 

В приведенных ниже инструкциях предполагается, что у вас уже есть доступ к оболочке на вашем устройстве OpenWRT. Хотя эти команды можно выполнять через веб-интерфейс LuCI, это категорически не рекомендуется.
Обычно доступ к командной строке осуществляется через SSH или последовательную консоль.

На устройствах с флэш-памятью объемом 8 МБ и более должно быть достаточно места для установки необходимых пакетов, в противном случае создайте пользовательский образ. Рекомендуется удалить все дополнительные пакеты, которые вы установили, поскольку они только отнимают место. Если вы не хотите делать это вручную, возможно, вам захочется очистить свою установку и конфигурацию с помощью команды firstboot. После создания extroot у вас будет достаточно места для установки дополнительных пакетов.

Extroot может быть любым, что может монтировать block. В настоящее время block создает некоторые ограничения на то, каким может быть extroot. Это должна быть файловая система типа ext2/3/4, f2fs, btrfs, ntfs или ubifs (обратите внимание, что это не может быть файловая система FAT16/32). В большинстве случаев эта файловая система будет храниться на USB-накопителе. Однако она также может храниться на SD-карте или SATA-накопителе, подключенном через e-sata, или даже на сетевом устройстве блокировки (при условии, что оно настроено достаточно рано). Если вы используете устройство, подключенное по USB, следуйте руководству по установке USB, чтобы настроить USB-накопитель.

В приведенном ниже примере предполагается, что вы будете создавать свой extroot как файловую систему ext4 с подключенным USB-накопителем. Процесс аналогичен для других типов устройств.

Для установки этих пакетов требуется значительный объем дополнительного хранилища. Если вы полностью загрузите файловую систему, установив их, вам, вероятно, придется перепрошить всю систему. Поэтому, если вы считаете, что уже близки к заполнению файловой системы, сначала удалите некоторые установленные пакеты. Хорошими кандидатами на удаление являются ntfs3 и ntfs3-utils: вы можете переустановить их позже, после установки extroot.

Понадобится USB-накопитель. ВСЕ данные на нём будут ПОТЕРЯНЫ.

Важные предупреждения:
    - Скрипт уничтожит все данные на /dev/sda
    - Устройство /dev/sda должно быть постоянно подключено
    - Рекомендуется сделать резервную копию конфигурации перед выполнением

Подготовка
- Убедиться, что в системе доступны пакеты: block-mount, kmod-fs-ext4, e2fsprogs, parted, kmod-usb-storage.
- Установить USB-накопитель в роутер.

Этот набор команд предназначен для расширения корневой файловой системы OpenWRT на отдельный раздел диска.

Подключитесь через ssh к устройству.

## 1. **Настройка переменных**
```bash
DISK="/dev/sda"
```
Определяет целевой диск (обычно USB-накопитель или SSD).

## 2. **Создание раздела**
```bash
parted -s ${DISK} -- mklabel gpt mkpart extroot 2048s -2048s
```
- `mklabel gpt` - создает GPT таблицу разделов
- `mkpart extroot 2048s -2048s` - создает раздел от 2048-го сектора до предпоследнего 2048-го сектора
- `-s` - тихий режим (без запросов)

## 3. **Создание файловой системы**
```bash
DEVICE="${DISK}1"
mkfs.ext4 -L extroot ${DEVICE}
```
- Создает файловую систему ext4 на первом разделе
- `-L extroot` - устанавливает метку раздела

## 4. **Получение UUID нового раздела**
```bash
eval $(block info ${DEVICE} | grep -o -e 'UUID="\S*"')
```
Извлекает UUID созданного раздела в переменную `${UUID}`

## 5. **Получение текущей точки монтирования overlay**
```bash
eval $(block info | grep -o -e 'MOUNT="\S*/overlay"')
```
Находит текущую точку монтирования overlay (обычно внутренняя память) в переменную `${MOUNT}`

## 6. **Настройка fstab для нового корня**
```bash
uci -q delete fstab.extroot
uci set fstab.extroot="mount"
uci set fstab.extroot.uuid="${UUID}"
uci set fstab.extroot.target="${MOUNT}"
uci commit fstab
```
Настраивает автоматическое монтирование нового раздела как корневой файловой системы.

## 7. **Настройка fstab для оригинального overlay**
```bash
ORIG="$(block info | sed -n -e '/MOUNT="\S*\/overlay"/s/:\s.*$//p')"
```
Эта команда ищет оригинальное overlay устройство (обычно внутреннюю флеш-память маршрутизатора) и извлекает его путь (например, `/dev/mtdblock3`).

```bash
uci -q delete fstab.rwm
```
- **`uci`** - Unified Configuration Interface (основной инструмент управления конфигурацией OpenWRT)
- **`-q`** - quiet mode (подавляет вывод ошибок, если секция не существует)
- **`delete fstab.rwm`** - удаляет конфигурационную секцию с именем `rwm` в файле `/etc/config/fstab`
- Удаляет старую конфигурацию монтирования (если она существует)
- Это предотвращает конфликты при повторном выполнении скрипта

```bash
uci set fstab.rwm="mount"
```
- **`set fstab.rwm="mount"`** - создает новую секцию `rwm` типа `mount` в конфигурации fstab
- Создает секцию с именем `rwm` (read-write memory или read-write mount)
- Указывает, что это конфигурация точки монтирования (а не swap или что-то другое)
- В файле `/etc/config/fstab` это создаст:
  ```
  config mount 'rwm'
  ```

```bash
uci set fstab.rwm.device="${ORIG}"
```
- Устанавливает параметр `device` в секции `rwm`
- Значение - оригинальное устройство с overlay (внутренняя память)
- В файле конфигурации:
  ```
  config mount 'rwm'
      option device '/dev/mtdblock3'
  ```

```bash
uci set fstab.rwm.target="/rwm"
```
- Устанавливает точку монтирования `/rwm` для оригинального устройства
- `target` - это параметр, определяющий, куда будет смонтировано устройство
- В файле конфигурации:
  ```
  config mount 'rwm'
      option device '/dev/mtdblock3'
      option target '/rwm'
  ```

```bash
uci commit fstab
```
- Сохраняет изменения в постоянное хранилище
- Без этой команды изменения будут только в памяти и потеряются при перезагрузке
- Записывает изменения в файл `/etc/config/fstab`

```bash
config mount 'rwm'
    option device '/dev/mtdblock3'    # Оригинальное внутреннее устройство
    option target '/rwm'             # Точка монтирования
    option enabled '1'               # Автоматически добавляется
```

**Новый раздел (`/dev/sda1`)** → становится основным overlay (корневая ФС)
**Старый overlay (`/dev/mtdblock3`)** → монтируется как `/rwm`
**Сохраняем доступ к оригинальной памяти** - можно читать/записывать данные
**Резервное копирование** - можно копировать конфигурации обратно в оригинальную память
**Восстановление** - если внешний диск отключится, можно перемонтировать оригинальную память
**Экономия ресурсов** - используем оба устройства оптимально

## 8. **Копирование данных**
```bash
mount ${DEVICE} /mnt
```
- Монтирует новый раздел в `/mnt`

```bash
tar -C ${MOUNT} -cvf - . | tar -C /mnt -xf -
```
Это **конвейер (pipe)** из двух команд `tar`, разделенных символом `|`.

## **Разбор первой части: `tar -C ${MOUNT} -cvf - .`**

### **Параметры:**
- **`-C ${MOUNT}`** - Change directory (перейти в каталог `${MOUNT}`)
  - `${MOUNT}` = оригинальная точка монтирования overlay (например, `/overlay`)
  - Пример: `-C /overlay`

- **`-c`** - Create archive (создать архив)

- **`-v`** - Verbose (подробный вывод, показывает обрабатываемые файлы)

- **`-f -`** - File = stdout (использовать стандартный вывод как "файл" архива)
  - `-` означает стандартный вывод (stdout)
  - Вместо создания файла на диске, выводит архив в консоль

- **`.`** - Текущий каталог (тот, в который мы перешли с `-C`)
  - Архивирует ВСЕ содержимое каталога `${MOUNT}`

### **Что делает первая часть:**
```bash
# Эквивалент без конвейера:
cd /overlay
tar -cvf archive.tar .
```
Но вместо сохранения в файл `archive.tar`, выводит поток данных в конвейер.

## **Разбор символа `|` (pipe)**
- **`|`** - Конвейер (pipe)
- Перенаправляет **stdout (вывод)** первой команды в **stdin (ввод)** второй команды
- **Нет промежуточного файла** - данные передаются напрямую в памяти

## **Разбор второй части: `tar -C /mnt -xf -`**

### **Параметры:**
- **`-C /mnt`** - Change directory (перейти в `/mnt`)
  - `/mnt` - точка монтирования нового раздела

- **`-x`** - eXtract archive (распаковать архив)

- **`-f -`** - File = stdin (читать архив из стандартного ввода)
  - `-` означает стандартный ввод (stdin)

### **Что делает вторая часть:**
```bash
# Эквивалент без конвейера:
cd /mnt
tar -xvf archive.tar
```
Но вместо чтения из файла `archive.tar`, читает данные из конвейера.

## **Полный эквивалент без конвейера:**
```bash
# 1. Создать архив во временный файл
tar -C /overlay -cvf /tmp/backup.tar .

# 2. Распаковать архив
tar -C /mnt -xvf /tmp/backup.tar

# 3. Удалить временный файл
rm /tmp/backup.tar
```

## **Почему используют конвейер вместо файла?**

### **Преимущества:**
1. **Экономия места** - не нужен дополнительный свободный объем для временного файла
2. **Скорость** - данные передаются напрямую, без записи на диск
3. **Атомарность** - либо все скопируется, либо ничего (меньше риска повреждений)
4. **Безопасность** - нет временных файлов, которые можно удалить или повредить

### **Визуализация потока данных:**
```
/overlay/        → tar (упаковка) → stdout → pipe → stdin → tar (распаковка) → /mnt/
├── etc/                     │                           │                     ├── etc/
├── root/                   ▼                           ▼                     ├── root/
└── upper/           [бинарные данные           [распаковка в]               └── upper/
                     архива в потоке]             [памяти]
```

---

## **Что конкретно копируется?**

### **Содержимое `${MOUNT}` (обычно `/overlay`):**
```
/overlay/
├── etc/              # Конфигурации OpenWRT
│   ├── config/       # Файлы UCI конфигурации
│   ├── dropbear/     # SSH ключи
│   └── ...
├── root/             # Домашний каталог root
├── upper/            # OverlayFS: верхний слой
├── work/             # OverlayFS: рабочий каталог
└── ...
```

### **Важные особенности копирования:**
1. **Сохраняются права доступа** (permissions)
2. **Сохраняются владельцы файлов** (ownership)
3. **Сохраняются символические ссылки** (symlinks)
4. **Сохраняются временные метки** (timestamps)
5. **Рекурсивно копируются все подкаталоги**

Этот метод - стандартный и надежный способ миграции файловых систем в Unix-подобных ОС, особенно когда важно сохранить все метаданные файлов.

## **Цель скрипта:**
Перенести корневую файловую систему OpenWRT с ограниченной внутренней памяти на внешний накопитель для увеличения доступного пространства.

## **Важные предупреждения:**
1. Скрипт уничтожит все данные на `/dev/sda`
2. Требуется перезагрузка для применения изменений
3. Устройство `/dev/sda` должно быть постоянно подключено
4. Рекомендуется сделать резервную копию конфигурации перед выполнением


Проверка
Через Web интерфейс
    **LuCI → System → Mount Points** должен быть показан раздел на внешнем USB устройстве подмонтированный как overlay.
    **LuCI → System → Software** должно быть показано большее свободное пространство на overlay разделе.
Через командную строку
    Раздел на внешнем USB устройстве должен быть подмонтирован как overlay Свободное пространство в корневом разделе / должно быть равно пространству на /overlay.
```bash
# grep -e /overlay /etc/mtab
/dev/sda1 /overlay ext4 rw,relatime,data=ordered
overlayfs:/overlay / overlay rw,noatime,lowerdir=/,upperdir=/overlay/upper,workdir=/overlay/work
 
# df /overlay /
Filesystem           1K-blocks      Used Available Use% Mounted on
/dev/sda1              7759872    477328   7221104   6% /overlay
overlayfs:/overlay     7759872    477328   7221104   6% /
```

Сохранение списков программных пакетов при загрузке
Сохранение статуса установленных пакетов opkg в /usr/lib/opkg/lists хранящемся в extroot, а не в RAM, экономит некоторую оперативную память и сохраняет списки пакетов доступными после перезагрузки.

Через Web интерфейс
1. **LuCI → System → Software → Configuration**

смените
```bash
lists_dir ext /var/opkg-lists
```
на
```bash
lists_dir ext /usr/lib/opkg/lists
```
это должно выглядеть примерно так:
```bash
dest root /
dest ram /tmp
lists_dir ext /usr/lib/opkg/lists
option overlay_root /overlay
option check_signature
```
2. **LuCI → System → Software → Actions → Update lists** производит первоначальное обновление списка пакетов на extroot